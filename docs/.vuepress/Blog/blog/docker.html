<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker 使用 | Encaik-个人博客</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="manifest" href="/json/manifest.json">
    <link rel="apple-touch-icon" href="/img/favicon.ico">
    <link rel="mask-icon" href="/img/favicon.ico" color="#fff">
    <meta name="description" content="Encaik-个人博客">
    <meta name="theme-color" content="#fff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/img/favicon.ico">
    <meta name="msapplication-TileColor" content="#fff">
    <link rel="preload" href="/assets/css/0.styles.d86e72b5.css" as="style"><link rel="preload" href="/assets/js/app.10a5ea0c.js" as="script"><link rel="preload" href="/assets/js/3.675f2b1c.js" as="script"><link rel="preload" href="/assets/js/2.a5cba7f5.js" as="script"><link rel="preload" href="/assets/js/10.54d1713a.js" as="script"><link rel="preload" href="/assets/js/4.154f069f.js" as="script"><link rel="prefetch" href="/assets/js/11.ac8a0896.js"><link rel="prefetch" href="/assets/js/12.27527816.js"><link rel="prefetch" href="/assets/js/13.fada1f20.js"><link rel="prefetch" href="/assets/js/14.fa897bbc.js"><link rel="prefetch" href="/assets/js/15.3c83c875.js"><link rel="prefetch" href="/assets/js/16.e59fea99.js"><link rel="prefetch" href="/assets/js/17.bd931464.js"><link rel="prefetch" href="/assets/js/18.ee934170.js"><link rel="prefetch" href="/assets/js/19.2a83668a.js"><link rel="prefetch" href="/assets/js/20.795218c4.js"><link rel="prefetch" href="/assets/js/21.884b2a59.js"><link rel="prefetch" href="/assets/js/22.3e91d08f.js"><link rel="prefetch" href="/assets/js/23.79760591.js"><link rel="prefetch" href="/assets/js/24.a00b113f.js"><link rel="prefetch" href="/assets/js/25.a911edca.js"><link rel="prefetch" href="/assets/js/26.297ca829.js"><link rel="prefetch" href="/assets/js/27.ef27b0f0.js"><link rel="prefetch" href="/assets/js/28.a1bd7426.js"><link rel="prefetch" href="/assets/js/29.a1c57457.js"><link rel="prefetch" href="/assets/js/30.28e8b928.js"><link rel="prefetch" href="/assets/js/31.0acc698f.js"><link rel="prefetch" href="/assets/js/32.e3177269.js"><link rel="prefetch" href="/assets/js/33.883e83fb.js"><link rel="prefetch" href="/assets/js/34.2814e88a.js"><link rel="prefetch" href="/assets/js/35.d25ac460.js"><link rel="prefetch" href="/assets/js/36.c6ce2c7a.js"><link rel="prefetch" href="/assets/js/37.e5818683.js"><link rel="prefetch" href="/assets/js/38.36440d80.js"><link rel="prefetch" href="/assets/js/39.69655e60.js"><link rel="prefetch" href="/assets/js/40.2782da6d.js"><link rel="prefetch" href="/assets/js/41.0101b9c7.js"><link rel="prefetch" href="/assets/js/42.02301c7b.js"><link rel="prefetch" href="/assets/js/43.41cf74eb.js"><link rel="prefetch" href="/assets/js/44.c3caec8b.js"><link rel="prefetch" href="/assets/js/45.7bc11f5a.js"><link rel="prefetch" href="/assets/js/46.b6fda013.js"><link rel="prefetch" href="/assets/js/47.79eee1b6.js"><link rel="prefetch" href="/assets/js/48.63963105.js"><link rel="prefetch" href="/assets/js/5.081a9547.js"><link rel="prefetch" href="/assets/js/6.50d5a1ff.js"><link rel="prefetch" href="/assets/js/7.e5a32f2e.js"><link rel="prefetch" href="/assets/js/8.9cb39557.js"><link rel="prefetch" href="/assets/js/9.0ea00540.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d86e72b5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Encaik-个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博文</a></div><div class="nav-item"><a href="/note/" class="nav-link">杂记</a></div><div class="nav-item"><a href="/repo/" class="nav-link">项目</a></div><div class="nav-item"><a href="/road/" class="nav-link">学习路径</a></div><div class="nav-item"><a href="https://github.com/Encaik" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/encaik" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">博文</a></div><div class="nav-item"><a href="/note/" class="nav-link">杂记</a></div><div class="nav-item"><a href="/repo/" class="nav-link">项目</a></div><div class="nav-item"><a href="/road/" class="nav-link">学习路径</a></div><div class="nav-item"><a href="https://github.com/Encaik" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://gitee.com/encaik" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/" aria-current="page" class="sidebar-link">前端工程化项目构建流程及基本结构</a></li><li><a href="/blog/tensorflow.html" class="sidebar-link">学习使用Tensorflow.js机器学习</a></li><li><a href="/blog/git.html" class="sidebar-link">Git语法及使用</a></li><li><a href="/blog/vuepress.html" class="sidebar-link">Vuepress搭建博客</a></li><li><a href="/blog/koa2-learn.html" class="sidebar-link">Koa2基本学习</a></li><li><a href="/blog/docker.html" aria-current="page" class="active sidebar-link">Docker 使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/docker.html#安装" class="sidebar-link">安装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/docker.html#ubuntu" class="sidebar-link">Ubuntu</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/docker.html#概念" class="sidebar-link">概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/docker.html#镜像" class="sidebar-link">镜像</a></li><li class="sidebar-sub-header"><a href="/blog/docker.html#容器" class="sidebar-link">容器</a></li></ul></li></ul></li><li><a href="/blog/docker-compose.html" class="sidebar-link">Docker-compose使用</a></li><li><a href="/blog/docker-project.html" class="sidebar-link">docker-compose部署流程</a></li><li><a href="/blog/react.html" class="sidebar-link">React学习-创建项目</a></li><li><a href="/blog/react-native.html" class="sidebar-link">React Native学习-创建项目</a></li><li><a href="/blog/typescript.html" class="sidebar-link">Typescr学习-实现基础爬虫</a></li><li><a href="/blog/vuetestutils.html" class="sidebar-link">vue-test-utils学习-用jest进行单元测试</a></li><li><a href="/blog/vuetestutils2.html" class="sidebar-link">vue-test-utils学习-用nightwatch进行e2e测试</a></li><li><a href="/blog/egg.html" class="sidebar-link">学习使用Egg.js搭建后端</a></li><li><a href="/blog/flutter.html" class="sidebar-link">学习使用Flutter进行移动端开发</a></li><li><a href="/blog/tonejs.html" class="sidebar-link">学习使用Tone.js制作网页版乐器</a></li><li><a href="/blog/vue2.html" class="sidebar-link">从头开始学习Vue2源码</a></li><li><a href="/blog/vue3.html" class="sidebar-link">从头开始学习Vue3源码</a></li><li><a href="/blog/angular-learn.html" class="sidebar-link">学习使用Angular9</a></li><li><a href="/blog/golang-learn.html" class="sidebar-link">学习使用Golang</a></li><li><a href="/blog/map.html" class="sidebar-link">地图api及库总结</a></li><li><a href="/blog/http.html" class="sidebar-link">前端请求发展及使用</a></li></ul> </aside> <main class="page"> <img src="/img/blog/docker.png" alt class="banner"> <div class="theme-default-content content__default"><h1 id="docker-使用"><a href="#docker-使用" class="header-anchor">#</a> Docker 使用</h1> <h2 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h2> <h3 id="ubuntu"><a href="#ubuntu" class="header-anchor">#</a> Ubuntu</h3> <h4 id="卸载旧版本"><a href="#卸载旧版本" class="header-anchor">#</a> 卸载旧版本</h4> <p>docker的旧版本被称为docker,docker.io 或docker-engine。如果已安装,请卸载它们:</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> remove docker docker-engine docker.io containerd runc
</code></pre></div><h4 id="从存储库安装"><a href="#从存储库安装" class="header-anchor">#</a> 从存储库安装</h4> <h5 id="设置存储库"><a href="#设置存储库" class="header-anchor">#</a> 设置存储库</h5> <ol><li><p>更新apt包索引:</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update
</code></pre></div></li> <li><p>安装软件包以允许apt通过HTTPS使用存储库:</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> apt-transport-https ca-certificates <span class="token function">curl</span> gnupg-agent software-properties-common
</code></pre></div></li> <li><p>添加Docker的官方GPG密钥:</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">curl</span> -fsSL https://download.docker.com/linux/ubuntu/gpg <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> -
</code></pre></div><p><code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>通过搜索指纹的后8个字符,验证您现在是否拥有带有指纹的密钥 。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> apt-key fingerprint 0EBFCD88

pub   rsa4096 <span class="token number">2017</span>-02-22 <span class="token punctuation">[</span>SCEA<span class="token punctuation">]</span>
      9DC8 <span class="token number">5822</span> 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           <span class="token punctuation">[</span> unknown<span class="token punctuation">]</span> Docker Release <span class="token punctuation">(</span>CE deb<span class="token punctuation">)</span> <span class="token operator">&lt;</span>docker@docker.com<span class="token operator">&gt;</span>
sub   rsa4096 <span class="token number">2017</span>-02-22 <span class="token punctuation">[</span>S<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>使用以下命令来设置稳定的存储库。要添加 每晚或测试存储库,请在以下命令中的单词后面添加nightly或test（或同时添加）stable。</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>下面的lsb_release -cs子命令返回Ubuntu发行版的名称,例如xenial。有时,在Linux Mint等发行版中,您可能需要更改$(lsb_release -cs) 为父Ubuntu发行版。例如,如果您使用 Linux Mint Tessa,则可以使用bionic。Docker对未经测试和不受支持的Ubuntu发行版不提供任何保证。</p></div> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> add-apt-repository <span class="token string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="token variable"><span class="token variable">$(</span>lsb_release -cs<span class="token variable">)</span></span> stable&quot;</span>
</code></pre></div></li></ol> <h5 id="安装docker"><a href="#安装docker" class="header-anchor">#</a> 安装Docker</h5> <ol><li><p>更新apt包索引。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update
</code></pre></div></li> <li><p>安装最新版本的Docker Engine-Community和containerd,或者转到下一步安装特定版本:</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce docker-ce-cli containerd.io
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>如果启用了多个Docker存储库,则在未在apt-get installor apt-get update命令中指定版本的情况下进行安装或更新将始终安装可能的最高版本,这可能不适合您的稳定性需求。</p></div></li> <li><p>要安装特定版本的Docker Engine-Community,请在存储库中列出可用版本,然后选择并安装:</p> <p>a. 列出您的仓库中可用的版本:</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">apt-cache</span> madison docker-ce

  docker-ce <span class="token operator">|</span> <span class="token number">5</span>:18.09.1~3-0~ubuntu-xenial <span class="token operator">|</span> https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  docker-ce <span class="token operator">|</span> <span class="token number">5</span>:18.09.0~3-0~ubuntu-xenial <span class="token operator">|</span> https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  docker-ce <span class="token operator">|</span> <span class="token number">18.06</span>.1~ce~3-0~ubuntu       <span class="token operator">|</span> https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  docker-ce <span class="token operator">|</span> <span class="token number">18.06</span>.0~ce~3-0~ubuntu       <span class="token operator">|</span> https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages
  <span class="token punctuation">..</span>.
</code></pre></div><p>b. 使用第二列中的版本字符串安装特定版本,例如5:18.09.1~3-0~ubuntu-xenial。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> docker-ce<span class="token operator">=</span><span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">&gt;</span> docker-ce-cli<span class="token operator">=</span><span class="token operator">&lt;</span>VERSION_STRING<span class="token operator">&gt;</span> containerd.io
</code></pre></div></li> <li><p>通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker run hello-world
</code></pre></div><p>此命令下载测试图像并在容器中运行。容器运行时,它会打印参考消息并退出。</p></li></ol> <h4 id="从软件包安装"><a href="#从软件包安装" class="header-anchor">#</a> 从软件包安装</h4> <p>如果您不能使用Docker的存储库来安装Docker Engine-Community,则可以下载.deb要发布的 文件并手动安装。每次升级Docker时,都需要下载一个新文件。</p> <ol><li><p>去<a href="https://download.docker.com/linux/ubuntu/dists/" target="_blank" rel="noopener noreferrer">https://download.docker.com/linux/ubuntu/dists/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>选择你的Ubuntu版本,浏览pool/stable/,选择amd64,armhf,arm64,ppc64el,或s390x,并下载.deb文件对于docker引擎。</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>要安装夜间 软件包,stable请将URL中的单词更改 为nightly。 了解每晚和测试频道。</p></div></li> <li><p>安装Docker Engine-Community,将下面的路径更改为您下载Docker软件包的路径。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> dpkg -i /path/to/package.deb
</code></pre></div><p>Docker守护程序会自动启动。</p></li> <li><p>通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker run hello-world
</code></pre></div><p>此命令下载测试图像并在容器中运行。容器运行时,它会打印参考消息并退出。</p></li></ol> <h2 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h2> <h3 id="镜像"><a href="#镜像" class="header-anchor">#</a> 镜像</h3> <h4 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h4> <p>在 Docker 的术语里，一个只读层被称为镜像，一个镜像是永久不会变的。</p> <p>由于 Docker 使用一个统一文件系统，Docker 进程认为整个文件系统是以读写方式挂载的。 但是所有的变更都发生顶层的可写层，而下层的原始的只读镜像文件并未变化。由于镜像不 可写，所以镜像是无状态的。</p> <h5 id="父镜像"><a href="#父镜像" class="header-anchor">#</a> 父镜像</h5> <p>每一个镜像都可能依赖于由一个或多个下层的组成的另一个镜像。我们有时说，下层那个 镜像是上层镜像的父镜像。</p> <h5 id="基础镜像"><a href="#基础镜像" class="header-anchor">#</a> 基础镜像</h5> <p>一个没有任何父镜像的镜像，谓之基础镜像。</p> <h5 id="镜像id"><a href="#镜像id" class="header-anchor">#</a> 镜像ID</h5> <p>所有镜像都是通过一个 64 位十六进制字符串 （内部是一个 256 bit 的值）来标识的。 为简化使用，前 12 个字符可以组成一个短ID，可以在命令行中使用。短ID还是有一定的 碰撞机率，所以服务器总是返回长ID。</p> <h4 id="获取镜像"><a href="#获取镜像" class="header-anchor">#</a> 获取镜像</h4> <p>可以使用 docker pull 命令来从仓库获取所需要的镜像。</p> <p>下面的例子将从 Docker Hub 仓库下载一个 Ubuntu 12.04 操作系统的镜像。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker pull ubuntu:12.04
Pulling repository ubuntu
ab8e2728644c: Pulling dependent layers
511136ea3c5a: Download complete
5f0ffaa9455e: Download complete
a300658979be: Download complete
904483ae0c30: Download complete
ffdaafd1ca50: Download complete
d047ae21eeaf: Download complete
</code></pre></div><p>下载过程中，会输出获取镜像的每一层信息。</p> <p>该命令实际上相当于<code>$ sudo docker pull registry.hub.docker.com/ubuntu:12.04</code>命令，即从注册服务器registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。</p> <p>有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。 从其它仓库下载时需要指定完整的仓库注册服务器地址。例如</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker pull dl.dockerpool.com:5000/ubuntu:12.04
Pulling dl.dockerpool.com:5000/ubuntu
ab8e2728644c: Pulling dependent layers
511136ea3c5a: Download complete
5f0ffaa9455e: Download complete
a300658979be: Download complete
904483ae0c30: Download complete
ffdaafd1ca50: Download complete
d047ae21eeaf: Download complete
</code></pre></div><p>完成后，即可随时使用该镜像了，例如创建一个容器，让其中运行 bash 应用。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker run -t -i ubuntu:12.04 /bin/bash
root@fe7fc4bd8fc9:/<span class="token comment">#</span>
</code></pre></div><h4 id="列出本地镜像"><a href="#列出本地镜像" class="header-anchor">#</a> 列出本地镜像</h4> <p>使用 docker images 显示本地已有的镜像。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker images
REPOSITORY       TAG      IMAGE ID      CREATED      VIRTUAL SIZE
ubuntu           <span class="token number">12.04</span>    74fe38d11401  <span class="token number">4</span> weeks ago  <span class="token number">209.6</span> MB
ubuntu           precise  74fe38d11401  <span class="token number">4</span> weeks ago  <span class="token number">209.6</span> MB
ubuntu           <span class="token number">14.04</span>    99ec81b80c55  <span class="token number">4</span> weeks ago  <span class="token number">266</span> MB
ubuntu           latest   99ec81b80c55  <span class="token number">4</span> weeks ago  <span class="token number">266</span> MB
ubuntu           trusty   99ec81b80c55  <span class="token number">4</span> weeks ago  <span class="token number">266</span> MB
<span class="token punctuation">..</span>.
</code></pre></div><p>在列出信息中，可以看到几个字段信息</p> <ul><li>来自于哪个仓库，比如 ubuntu</li> <li>镜像的标记，比如 14.04</li> <li>它的 ID 号（唯一）</li> <li>创建时间</li> <li>镜像大小</li></ul> <p>其中镜像的 ID 唯一标识了镜像，注意到 ubuntu:14.04 和 ubuntu:trusty 具有相同的镜像 ID，说明它们实际上是同一镜像。</p> <p>TAG 信息用来标记来自同一个仓库的不同镜像。例如 ubuntu 仓库中有多个镜像，通过 TAG 信息来区分发行版本，例如 10.04、12.04、12.10、13.04、14.04 等。例如下面的命令指定使用镜像 ubuntu:14.04 来启动一个容器。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker run -t -i ubuntu:14.04 /bin/bash
</code></pre></div><p>如果不指定具体的标记，则默认使用 latest 标记信息。</p> <h4 id="创建镜像"><a href="#创建镜像" class="header-anchor">#</a> 创建镜像</h4> <p>创建镜像有很多方法，用户可以从 Docker Hub 获取已有镜像并更新，也可以利用本地文件系统创建一个。</p> <h5 id="修改已有镜像"><a href="#修改已有镜像" class="header-anchor">#</a> 修改已有镜像</h5> <p>先使用下载的镜像启动容器。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker run -t -i training/sinatra /bin/bash
root@0b2616b0e5a8:/<span class="token comment">#</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>记住容器的 ID，稍后还会用到。</p></div> <p>在容器中添加 json 和 gem 两个应用。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>root@0b2616b0e5a8:/<span class="token comment"># gem install json</span>
</code></pre></div><p>当结束后，我们使用 exit 来退出，现在我们的容器已经被我们改变了，使用 docker commit 命令来提交更新后的副本。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker commit -m <span class="token string">&quot;Added json gem&quot;</span> -a <span class="token string">&quot;Docker Newbee&quot;</span> 0b2616b0e5a8 ouruser/sinatra:v2
4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
</code></pre></div><p>其中，-m 来指定提交的说明信息，跟我们使用的版本控制工具一样；-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID 信息。</p> <p>使用 docker images 来查看新创建的镜像。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker images
REPOSITORY          TAG     IMAGE ID       CREATED       VIRTUAL SIZE
training/sinatra    latest  5bc342fa0b91   <span class="token number">10</span> hours ago  <span class="token number">446.7</span> MB
ouruser/sinatra     v2      3c59e02ddd1a   <span class="token number">10</span> hours ago  <span class="token number">446.7</span> MB
ouruser/sinatra     latest  5db5f8471261   <span class="token number">10</span> hours ago  <span class="token number">446.7</span> MB
</code></pre></div><p>之后，可以使用新的镜像来启动容器</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker run -t -i ouruser/sinatra:v2 /bin/bash
root@78e82f680994:/<span class="token comment">#</span>
</code></pre></div><h5 id="利用-dockerfile-来创建镜像"><a href="#利用-dockerfile-来创建镜像" class="header-anchor">#</a> 利用 Dockerfile 来创建镜像</h5> <p>使用 docker commit 来扩展一个镜像比较简单，但是不方便在一个团队中分享。我们可以使用 docker build来创建一个新的镜像。为此，首先需要创建一个 Dockerfile，包含一些如何创建镜像的指令。</p> <p>新建一个目录和一个 Dockerfile</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">mkdir</span> sinatra
<span class="token punctuation">\</span>$ <span class="token builtin class-name">cd</span> sinatra
<span class="token punctuation">\</span>$ <span class="token function">touch</span> Dockerfile
</code></pre></div><p>Dockerfile 中每一条指令都创建镜像的一层，例如：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># This is a comment</span>
FROM ubuntu:14.04
MAINTAINER Docker Newbee <span class="token operator">&lt;</span>newbee@docker.com<span class="token operator">&gt;</span>
RUN <span class="token function">apt-get</span> -qq update
RUN <span class="token function">apt-get</span> -qqy <span class="token function">install</span> ruby ruby-dev
RUN gem <span class="token function">install</span> sinatra
</code></pre></div><p>Dockerfile 基本的语法是</p> <ul><li>使用#来注释</li> <li>FROM 指令告诉 Docker 使用哪个镜像作为基础</li> <li>接着是维护者的信息</li> <li>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用 apt-get 来安装了一些软件</li></ul> <p>编写完成 Dockerfile 后可以使用 docker build 来生成镜像。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker build -t<span class="token operator">=</span><span class="token string">&quot;ouruser/sinatra:v2&quot;</span> <span class="token builtin class-name">.</span>
Uploading context  <span class="token number">2.56</span> kB
Uploading context
Step <span class="token number">0</span> <span class="token builtin class-name">:</span> FROM ubuntu:14.04
---<span class="token operator">&gt;</span> 99ec81b80c55
Step <span class="token number">1</span> <span class="token builtin class-name">:</span> MAINTAINER Newbee <span class="token operator">&lt;</span>newbee@docker.com<span class="token operator">&gt;</span>
---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 7c5664a8a0c1
---<span class="token operator">&gt;</span> 2fa8ca4e2a13
Removing intermediate container 7c5664a8a0c1
Step <span class="token number">2</span> <span class="token builtin class-name">:</span> RUN <span class="token function">apt-get</span> -qq update
---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> b07cc3fb4256
---<span class="token operator">&gt;</span> 50d21070ec0c
Removing intermediate container b07cc3fb4256
Step <span class="token number">3</span> <span class="token builtin class-name">:</span> RUN <span class="token function">apt-get</span> -qqy <span class="token function">install</span> ruby ruby-dev
---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> a5b038dd127e
Selecting previously unselected package libasan0:amd64.
<span class="token punctuation">(</span>Reading database <span class="token punctuation">..</span>. <span class="token number">11518</span> files and directories currently installed.<span class="token punctuation">)</span>
Preparing to unpack <span class="token punctuation">..</span>./libasan0_4.8.2-19ubuntu1_amd64.deb <span class="token punctuation">..</span>.
Setting up ruby <span class="token punctuation">(</span><span class="token number">1</span>:1.9.3.4<span class="token punctuation">)</span> <span class="token punctuation">..</span>.
Setting up ruby1.9.1 <span class="token punctuation">(</span><span class="token number">1.9</span>.3.484-2ubuntu1<span class="token punctuation">)</span> <span class="token punctuation">..</span>.
Processing triggers <span class="token keyword">for</span> libc-bin <span class="token punctuation">(</span><span class="token number">2.19</span>-0ubuntu6<span class="token punctuation">)</span> <span class="token punctuation">..</span>.
---<span class="token operator">&gt;</span> 2acb20f17878
Removing intermediate container a5b038dd127e
Step <span class="token number">4</span> <span class="token builtin class-name">:</span> RUN gem <span class="token function">install</span> sinatra
---<span class="token operator">&gt;</span> Running <span class="token keyword">in</span> 5e9d0065c1f7
<span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span>
Successfully installed rack-protection-1.5.3
Successfully installed sinatra-1.4.5
<span class="token number">4</span> gems installed
---<span class="token operator">&gt;</span> 324104cde6ad
Removing intermediate container 5e9d0065c1f7
Successfully built 324104cde6ad
</code></pre></div><p>其中 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径。</p> <p>可以看到 build 进程在执行操作。它要做的第一件事情就是上传这个 Dockerfile 内容，因为所有的操作都要依据 Dockerfile 来进行。 然后，Dockfile 中的指令被一条一条的执行。每一步都创建了一个新的容器，在容器中执行指令并提交修改（就跟之前介绍过的 docker commit 一样）。当所有的指令都执行完毕之后，返回了最终的镜像 id。所有的中间步骤所产生的容器都被删除和清理了。</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>一个镜像不能超过 127 层</p></div> <p>此外，还可以利用 ADD 命令复制本地文件到镜像；用 EXPOSE 命令来向外部开放端口；用 CMD 命令来描述容器启动后运行的程序等。例如</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># put my local web site in myApp folder to /var/www</span>
ADD myApp /var/www
<span class="token comment"># expose httpd port</span>
EXPOSE <span class="token number">80</span>
<span class="token comment"># the command to run</span>
CMD <span class="token punctuation">[</span><span class="token string">&quot;/usr/sbin/apachectl&quot;</span>, <span class="token string">&quot;-D&quot;</span>, <span class="token string">&quot;FOREGROUND&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>现在可以利用新创建的镜像来启动一个容器。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker run -t -i ouruser/sinatra:v2 /bin/bash
root@8196968dac35:/<span class="token comment">#</span>
</code></pre></div><p>还可以用 docker tag 命令来修改镜像的标签。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker tag 5db5f8471261 ouruser/sinatra:devel
$ <span class="token function">sudo</span> docker images ouruser/sinatra
REPOSITORY          TAG     IMAGE ID      CREATED        VIRTUAL SIZE
ouruser/sinatra     latest  5db5f8471261  <span class="token number">11</span> hours ago   <span class="token number">446.7</span> MB
ouruser/sinatra     devel   5db5f8471261  <span class="token number">11</span> hours ago   <span class="token number">446.7</span> MB
ouruser/sinatra     v2      5db5f8471261  <span class="token number">11</span> hours ago   <span class="token number">446.7</span> MB
</code></pre></div><h5 id="从本地文件系统导入"><a href="#从本地文件系统导入" class="header-anchor">#</a> 从本地文件系统导入</h5> <p>要从本地文件系统导入一个镜像，可以使用 openvz（容器虚拟化的先锋技术）的模板来创建： openvz 的模板下载地址为 templates 。</p> <p>比如，先下载了一个 ubuntu-14.04 的镜像，之后使用以下命令导入：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">sudo</span> <span class="token function">cat</span> ubuntu-14.04-x86_64-minimal.tar.gz  <span class="token operator">|</span>docker <span class="token function">import</span> - ubuntu:14.04
</code></pre></div><p>然后查看新导入的镜像。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              <span class="token number">14.04</span>               05ac7c0b9383        <span class="token number">17</span> seconds ago      <span class="token number">215.5</span> MB
</code></pre></div><h5 id="上传镜像"><a href="#上传镜像" class="header-anchor">#</a> 上传镜像</h5> <p>用户可以通过 docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker push ouruser/sinatra
The push refers to a repository <span class="token punctuation">[</span>ouruser/sinatra<span class="token punctuation">]</span> <span class="token punctuation">(</span>len: <span class="token number">1</span><span class="token punctuation">)</span>
Sending image list
Pushing repository ouruser/sinatra <span class="token punctuation">(</span><span class="token number">3</span> tags<span class="token punctuation">)</span>
</code></pre></div><h4 id="存出和载入镜像"><a href="#存出和载入镜像" class="header-anchor">#</a> 存出和载入镜像</h4> <h5 id="存出镜像"><a href="#存出镜像" class="header-anchor">#</a> 存出镜像</h5> <p>如果要导出镜像到本地文件，可以使用 docker save 命令。</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              <span class="token number">14.04</span>               c4ff7513909d        <span class="token number">5</span> weeks ago         <span class="token number">225.4</span> MB
<span class="token punctuation">..</span>.
<span class="token punctuation">\</span><span class="token variable">$sudo</span> docker save -o ubuntu_14.04.tar ubuntu:14.04
</code></pre></div><h5 id="载入镜像"><a href="#载入镜像" class="header-anchor">#</a> 载入镜像</h5> <p>可以使用 docker load 从导出的本地文件中再导入到本地镜像库，例如</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker load --input ubuntu_14.04.tar
或
<span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker load <span class="token operator">&lt;</span> ubuntu_14.04.tar
</code></pre></div><p>这将导入镜像以及其相关的元数据信息（包括标签等）。</p> <h4 id="移除本地镜像"><a href="#移除本地镜像" class="header-anchor">#</a> 移除本地镜像</h4> <p>如果要移除本地的镜像，可以使用 docker rmi 命令。注意 docker rm 命令是移除容器。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">sudo</span> docker rmi training/sinatra
Untagged: training/sinatra:latest
Deleted: 5bc342fa0b91cabf65246837015197eecfa24b2213ed6a51a8974ae250fedd8d
Deleted: ed0fffdcdae5eb2c3a55549857a8be7fc8bc4241fb19ad714364cbfd7a56b22f
Deleted: 5c58979d73ae448df5af1d8142436d81116187a7633082650549c52c3a2418f0
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器。</p></div> <h4 id="镜像的实现原理"><a href="#镜像的实现原理" class="header-anchor">#</a> 镜像的实现原理</h4> <p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。</p> <p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p> <h3 id="容器"><a href="#容器" class="header-anchor">#</a> 容器</h3> <h4 id="基本结构"><a href="#基本结构" class="header-anchor">#</a> 基本结构</h4> <p>Dockerfile 由一行行命令语句组成，并且支持以 # 开头的注释行。</p> <p>一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p> <p>例如</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># This dockerfile uses the ubuntu image</span>
<span class="token comment"># VERSION 2 - EDITION 1</span>
<span class="token comment"># Author: docker_user</span>
<span class="token comment"># Command format: Instruction [arguments / command] ..</span>

<span class="token comment"># Base image to use, this must be set as the first line</span>
FROM ubuntu

<span class="token comment"># Maintainer: docker_user &lt;docker_user at email.com&gt; (@docker_user)</span>
MAINTAINER docker_user docker_user@email.com

<span class="token comment"># Commands to update the image</span>
RUN <span class="token builtin class-name">echo</span> <span class="token string">&quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/apt/sources.list
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y nginx
RUN <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token entity" title="\n">\n</span>daemon off;&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/nginx/nginx.conf

<span class="token comment"># Commands when creating a new container</span>
CMD /usr/sbin/nginx
</code></pre></div><p>其中，一开始必须指明所基于的镜像名称，接下来推荐说明维护者信息。</p> <p>后面则是镜像操作指令，例如 RUN 指令，RUN 指令将对镜像执行跟随的命令。每运行一条 RUN 指令，镜像添加新的一层，并提交。</p> <p>最后是 CMD 指令，来指定运行容器时的操作命令。</p> <p>下面是一个更复杂的例子</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># Nginx</span>
<span class="token comment">#</span>
<span class="token comment"># VERSION               0.0.1</span>

FROM      ubuntu
MAINTAINER Victor Vieux <span class="token operator">&lt;</span>victor@docker.com<span class="token operator">&gt;</span>

RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y inotify-tools nginx apache2 openssh-server

<span class="token comment"># Firefox over VNC</span>
<span class="token comment">#</span>
<span class="token comment"># VERSION               0.3</span>

FROM ubuntu

<span class="token comment"># Install vnc, xvfb in order to create a 'fake' display and firefox</span>
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y x11vnc xvfb firefox
RUN <span class="token function">mkdir</span> /.vnc
<span class="token comment"># Setup a password</span>
RUN x11vnc -storepasswd <span class="token number">1234</span> ~/.vnc/passwd
<span class="token comment"># Autostart firefox (might not be the best way, but it does the trick)</span>
RUN <span class="token function">bash</span> -c <span class="token string">'echo &quot;firefox&quot; &gt;&gt; /.bashrc'</span>

EXPOSE <span class="token number">5900</span>
CMD    <span class="token punctuation">[</span><span class="token string">&quot;x11vnc&quot;</span>, <span class="token string">&quot;-forever&quot;</span>, <span class="token string">&quot;-usepw&quot;</span>, <span class="token string">&quot;-create&quot;</span><span class="token punctuation">]</span>

<span class="token comment"># Multiple images example</span>
<span class="token comment">#</span>
<span class="token comment"># VERSION               0.1</span>

FROM ubuntu
RUN <span class="token builtin class-name">echo</span> foo <span class="token operator">&gt;</span> bar
<span class="token comment"># Will output something like ===&gt; 907ad6c2736f</span>

FROM ubuntu
RUN <span class="token builtin class-name">echo</span> moo <span class="token operator">&gt;</span> oink
<span class="token comment"># Will output something like ===&gt; 695d7793cbe4</span>

<span class="token comment"># You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span>
<span class="token comment"># /oink.</span>
</code></pre></div><h4 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h4> <p>指令的一般格式为 INSTRUCTION arguments，指令包括 FROM、MAINTAINER、RUN 等。</p> <h5 id="from"><a href="#from" class="header-anchor">#</a> FROM</h5> <p>格式为 FROM &lt;image&gt;或FROM &lt;image&gt;:&lt;tag&gt;。</p> <p>第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 FROM 指令（每个镜像一次）。</p> <h5 id="maintainer"><a href="#maintainer" class="header-anchor">#</a> MAINTAINER</h5> <p>格式为 MAINTAINER &lt;name&gt;，指定维护者信息。</p> <h5 id="run"><a href="#run" class="header-anchor">#</a> RUN</h5> <p>格式为 RUN &lt;command&gt; 或 RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。</p> <p>前者将在 shell 终端中运行命令，即 /bin/sh -c；后者则使用 exec 执行。指定使用其它终端可以通过第二种方式实现，例如 RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]。</p> <p>每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 \ 来换行。</p> <h5 id="cmd"><a href="#cmd" class="header-anchor">#</a> CMD</h5> <p>支持三种格式</p> <div class="language-text extra-class"><pre class="language-text"><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式；
CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；
CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给 ENTRYPOINT 的默认参数；
</code></pre></div><p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。</p> <p>如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。</p> <h5 id="expose"><a href="#expose" class="header-anchor">#</a> EXPOSE</h5> <p>格式为 EXPOSE &lt;port&gt; [&lt;port&gt;...]。</p> <p>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。</p> <h5 id="env"><a href="#env" class="header-anchor">#</a> ENV</h5> <p>格式为 ENV &lt;key&gt; &lt;value&gt;。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。</p> <p>例如</p> <div class="language-sh extra-class"><pre class="language-sh"><code>ENV PG_MAJOR <span class="token number">9.3</span>
ENV PG_VERSION <span class="token number">9.3</span>.4
RUN <span class="token function">curl</span> -SL http://example.com/postgres-<span class="token variable">$PG_VERSION</span>.tar.xz <span class="token operator">|</span> <span class="token function">tar</span> -xJC /usr/src/postgress <span class="token operator">&amp;&amp;</span> …
ENV <span class="token environment constant">PATH</span> /usr/local/postgres-<span class="token variable">$PG_MAJOR</span>/bin:<span class="token environment constant">$PATH</span>
</code></pre></div><h5 id="add"><a href="#add" class="header-anchor">#</a> ADD</h5> <p>格式为 ADD &lt;src&gt; &lt;dest&gt;。</p> <p>该命令将复制指定的 &lt;src&gt; 到容器中的 &lt;dest&gt;。 其中 &lt;src&gt; 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p> <h5 id="copy"><a href="#copy" class="header-anchor">#</a> COPY</h5> <p>格式为 COPY &lt;src&gt; &lt;dest&gt;。</p> <p>复制本地主机的 &lt;src&gt;（为 Dockerfile 所在目录的相对路径）到容器中的 &lt;dest&gt;。</p> <p>当使用本地目录为源目录时，推荐使用 COPY。
ENTRYPOINT</p> <p>两种格式：</p> <div class="language-text extra-class"><pre class="language-text"><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
ENTRYPOINT command param1 param2（shell中执行）。
</code></pre></div><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。</p> <p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。</p> <h5 id="volume"><a href="#volume" class="header-anchor">#</a> VOLUME</h5> <p>格式为 VOLUME [&quot;/data&quot;]。</p> <p>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p> <h5 id="user"><a href="#user" class="header-anchor">#</a> USER</h5> <p>格式为 USER daemon。</p> <p>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。</p> <p>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres。要临时获取管理员权限可以使用 gosu，而不推荐 sudo。</p> <h5 id="workdir"><a href="#workdir" class="header-anchor">#</a> WORKDIR</h5> <p>格式为 WORKDIR /path/to/workdir。</p> <p>为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。</p> <p>可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
</code></pre></div><p>则最终路径为 /a/b/c。</p> <h5 id="onbuild"><a href="#onbuild" class="header-anchor">#</a> ONBUILD</h5> <p>格式为 ONBUILD [INSTRUCTION]。</p> <p>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</p> <p>例如，Dockerfile 使用如下的内容创建了镜像 image-A。</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token punctuation">[</span><span class="token punctuation">...</span><span class="token punctuation">]</span>
ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python<span class="token punctuation">-</span>build <span class="token punctuation">-</span><span class="token punctuation">-</span>dir /app/src
<span class="token punctuation">[</span><span class="token punctuation">...</span><span class="token punctuation">]</span>
</code></pre></div><p>如果基于 image-A 创建新的镜像时，新的Dockerfile中使用 FROM image-A指定基础镜像时，会自动执行ONBUILD 指令内容，等价于在后面添加了两条指令。</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>FROM image<span class="token punctuation">-</span>A

<span class="token comment">#Automatically run the following</span>
ADD . /app/src
RUN /usr/local/bin/python<span class="token punctuation">-</span>build <span class="token punctuation">-</span><span class="token punctuation">-</span>dir /app/src
</code></pre></div><p>使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。</p> <h4 id="构建镜像"><a href="#构建镜像" class="header-anchor">#</a> 构建镜像</h4> <p>编写完成 Dockerfile 之后，可以通过 docker build 命令来构建镜像。</p> <p>基本的格式为 docker build [选项] 路径，该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来构建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 .dockerignore 文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。</p> <p>要指定镜像的标签信息，可以通过 -t 选项，例如</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token punctuation">\</span>$ <span class="token function">sudo</span> docker build -t myrepo/myapp /tmp/test1/
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">发布日期:</span> <span class="time">11/22/2019, 5:52:56 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/koa2-learn.html" class="prev">
        Koa2基本学习
      </a></span> <span class="next"><a href="/blog/docker-compose.html">
        Docker-compose使用
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.10a5ea0c.js" defer></script><script src="/assets/js/3.675f2b1c.js" defer></script><script src="/assets/js/2.a5cba7f5.js" defer></script><script src="/assets/js/10.54d1713a.js" defer></script><script src="/assets/js/4.154f069f.js" defer></script>
  </body>
</html>
